%project-final-report.tex
\documentclass{article}
\usepackage[letterpaper, margin=1.2in]{geometry}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xparse}

\lstset{language=C,keywordstyle={\bfseries \color{blue}}}

\begin{document}

\title{A Benchmark of Linux System Calls}
\author{Jian Li \and Ding Yuan}
\maketitle

\section{Introduction}

The purpsoe of this paper is to evaluate the performance of Linux system calls of different kernel versions.


\section{Experiments}

We chose Linux kernel version 4.x (4.0 - 4.14) and 3.x (3.0 - 3.19) for our performance tests. The system calls tested are listed in Tablea \ref{tab:syscalls}.

\begin{table}
    \centering
    \begin{tabular}{clcclcclc}
        \toprule
        syscall \# & name & eax & syscall \# & name & eax & syscall \# & name & eax \\
        \midrule
        2 & fork & 0x02     &  15 & chhmod & 0x0f   &  41 & dup & 0x29 \\
        3 & read & 0x03     &  18 & stat & 0x12     &  42 & pipe & 0x2a \\
        4 & write & 0x04    &  20 & getpid & 0x14   &  43 & times & 0x2b \\
        5 & open & 0x05     &  25 & stime & 0x19    &  51 & acct & 0x33 \\
        6 & close & 0x06    &  27 & alarm & 0x1b    &  60 & umask & 0x3c \\
        9 & link & 0x09     &  28 & fstat & 0x1c    &  63 & dup2 & 0x3f \\
        10 & unlink & 0x0a  &  30 & utime & 0x1e    &  64 & getppid & 0x40 \\
        11 & execve & 0x0b  &  38 & rename & 0x26   &  65 & getpgrp & 0x41 \\
        13 & time & 0x0d    &  39 & mkdir & 0x27    & \\
        14 & mknod & 0x0e   &  40 & rmdir & 0x28    & \\
        \bottomrule
    \end{tabular}
    \caption{\label{tab:syscalls} System Calls for Performance Test}
\end{table}


\subsection{clock\_gettime vs. RDTSC}

\subsubsection{clock\_gettime}

A common way of measuring execution time is using C library function \lstinline{clock_gettime}.
Setting the argument \lstinline{clk_id} to \lstinline{CLOCK_REALTIME} will return the real clock time in nanoseconds precision,
which could be used to measure the execution of system calls.

The problem in using \lstinline{clock_gettime} is that \lstinline{clock_gettime} itself is a system call
and requires context switch, which could add significant overhead to the test result.
Although Linux kernel uses vsyscall and VDSOs (Virtual Dynamically linked Shared Objects) to minimize
the overhead by avoiding context switch, the latency is still too high when considering our purpose.

\subsubsection{RDTSC}

Intel ia64/x86 architecture provided RDTSC (Read Time-Stamp Counter) instruction\cite{rdtsc} for directly counting CPU cycles. 
RDTSC will read the cycle counter into eax and edx registers, which is a monotonic increasing number.
This can be used for performance test if compatibility is not a consideration.

The basic benchmark code with RDTSC is listed below.

\begin{verbatim}
        asm volatile("RDTSC\n\t"
                    "mov %%edx, %0\n\t"
                    "mov %%eax, %1\n\t" : "=r" (x0h), "=r" (x0l)::);
        test_function();
        asm volatile("RDTSC\n\t"
                    "mov %%edx, %0\n\t"
                    "mov %%eax, %1\n\t" : "=r" (x1h), "=r" (x1l)::);
        start = (((uint64_t)x0h << 32) | x0l);
        end = (((uint64_t)x1h << 32) | x1l);
        cycles = end - start;
\end{verbatim}

Since RDTSC can be called from user space directly, it could run much faster than \lstinline{clock_gettime}.
The problem in RDTSC is its hardware dependency, i.e. it is only available on Intel architecture.
In our experiments this is not a problem since we do not consider compatibility.

\subsubsection{Out-of-order execution}

Modern CPU is equipped with out-of-order execution feature.
This is used to optimize the penalties due to different instruction latencies,
however this will make our benchmark difficult, because there is no guarantee that
RDTSC will be executed exactly before and after the test code.

The solution includes two extra instruction. First, the CPUID instruction will be called before RDTSC
instruction. CPUID can be executed at any privilege level and will force the CPU to serialize any instructions
before CPUID. In this way the CPUID and the following RDTSC can be guaranteed to be run before the test code.

However for the RDTSC call after the test function,
it is still possible for the instructions after RDTSC to be executed before RDTSC but after CPUID.
To solve this, RDTSCP instruction can be used insted of CPUID and RDTSC.
RDTSCP will read both cycle counter and CPU id, which is essentially an "atomic" operation
to ensure serialized instructions.

\subsubsection{Exclusive CPU ownership}

It is common to disble preemption(\lstinline{preempt_disable()}) and hard interrupts(\lstinline{raw_local_irq_save()})
to guarantee the exclusive CPU ownership when measuring CPU cycles. However in our case, these two functions
are only available in kernel mode, which is not reasonable when behchmarking system calls.
Therefore we will not use these functions.

\subsection{Environment}

The computer we used to run the benchmark test has an Intel Core i3-4300 CPU with 16GB memory. The CPU frequency is 3491.851MHz. The Linux OS is Ubuntu 16.04.

\subsubsection{Linux Setup}

The benchmarking is required to be repeated on multiple Linux kernels.
To minimize the overhead of compiling Linux kernels,
we decided to install pre-built kernel from Ubuntu kernel PPA\cite{kernelppa}. 

The kernel versions varies from 3.2 to 4.14. We were unable to test 3.1 and older kernels since they could not boot under Ubuntu 16.04.

In order to automate the benchmarking, a python script is used to automatically switch the default kernel by changing the grub config.
The linux OS as been changed so that root user will automatically login and execute the benchmark scripts after boot.


\section{Benchmark Result}

Due to limited space we only show part of the benchmark result here. Full result can be found at the project website.

First, the 



\section{Appendix}

\subsection{Linux settings}

To boot Ubuntu into text mode, use:

\begin{verbatim}
    sudo systemctl enable multi-user.target
    sudo systemctl set-default multi-user.target
\end{verbatim}

To run grub in text mode, change /etc/default/grub as:

\begin{verbatim}
    GRUB_CMDLINE_LINUX_DEFAULT="text nomodeset"
\end{verbatim}

To login as root user, edit /lib/systemd/system/getty@:

\begin{verbatim}
    ExecStart=-/sbin/agetty -a <USERNAME> --noclear %I $TERM
\end{verbatim}


\begin{thebibliography}{9}
    \raggedright
    \bibitem{kernelppa}
    \emph{Ubuntu Kernel PPA},
    http://kernel.ubuntu.com/~kernel-ppa/mainline/

    \bibitem{rdtsc}
    \emph{How to Benchmark Code Executions Times on Intel IA-32 and IA-64 Instruction Set Architectures},
    Intel Corporation,
    https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/ia-32-ia-64-benchmark-code-execution-paper.pdf
\end{thebibliography}


\end{document}

